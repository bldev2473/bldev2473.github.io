---
title: "[Algorithm] 동적 계획법"
date: 2021-03-11 00:10:00 -0000
categories: [Algorithm]
---

### 동적 계획법
- 동적 계획법(다이나믹 프로그래밍)<sup>Dynamic Programming</sup>: 복잡한 문제를 여러개의 간단한 하위 문제들로 분류하고 단순화하여 해결하는 방법
- 해결하려는 문제가 최적 부분구조<sup>Optimal Substructure</sup>와 중복되는 부분문제<sup>Overlapping Subproblem</sup>를 갖고 있다면, 동적 계획법으로 해결할 수 있음
    - 최적 부분 구조: 답을 구하기 위해 수행했던 계산을 반복해야 하는 문제의 구조
    - 동적 계획법을 사용하려면 먼저 최적 부분구조가 있는지 확인해야 함
- 동적 계획법의 전제조건과 제한
    1. 최적 부분구조 (Optimal Substructure): 문제의 최적 해답이 문제의 부분문제들의 최적 해답으로부터 구성되면 그 문제를 최적 부분구조라고 할 수 있음
    2. 중복되는 부분문제 (Overlapping Subproblems): 문제가 하위 문제로 쪼개질 수 있고 이 부분문제들이 여러번 재사용되는 경우, 또는 문제를 해결하는 과정에서 새로운 부분문제를 생성하는 것보다 재귀 알고리즘이 동일한 부분문제를 해결하는 경우 이 문제를 중첩 부분문제라고 말할 수 있음
- 위 두 조건을 만족한다면 분할 정복 문제는 동적 계획법으로 해결될 수 있음
- 문제에 어떤 전제조건과 제한이 있을 경우 동적 계획법을 문제에 적용할 수 있으며 이 경우 동적 계획법은 메모이제이션(memoization)과 도표 작성(tabulation) 기법을 가지고 분할 정복 접근방법을 확장함
- 동적 계획법은 부분문제를 풀고 결과를 저장한 후, 다음 부분문제(중복되는 부분문제)를 푸는 과정에서 저장된 결과를 사용함
    - 즉, 동적 계획법은 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법임

### 분할 정복 알고리즘과 동적 계획법
- 분할 정복 알고리즘과 동적 계획법 모두 문제를 재귀적으로 부분문제로 분류하여 해결하는 점에서 동일함
- 동적 계획법은 분할 정복 알고리즘의 확장이라고 볼 수 있음
- 부분문제들이 서로 겹치지 않으면 분할 정복 알고리즘, 부분문제들이 서로 겹쳐서 동일한 부분문제를 여러 번 해결하는 경우 동적 계획법
    - 즉, 동적 계획법은 문제들이 서로 영향을 미치고 있음
- 분할 정복 알고리즘을 사용하는 퀵 정렬에서는 설정된 기준 원소<sup>pivot</sup>에 대한 문제는 다시 해결하지 않음
- 반면 동적 계획법에서는 한 번 해결했던 문제를 다시 해결함
- 따라서 이미 해결된 부분문제에 대한 답을 저장해 놓고, 동일한 문제에 대해 다시 해결할 필요없이 이미 해결된 문제의 답을 반환하면 되며 이를 위해 메모이제이션 기법이 사용됨
- 재귀 함수를 사용하면 컴퓨터에는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야하므로 오버헤드가 발생할 수 있음
- 따라서 재귀 함수 대신에 반복문을 사용하면 오버헤드를 줄일 수 있음
    - 일반적으로 반복문을 이용한 동적 계획법 성능이 더 좋음

### 메모이제이션
- 메모이제이션<sup>Memoization</sup>: 프로그램이 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장하여 동일한 계산의 반복 수행을 제거함으로써 프로그램의 실행 속도를 빠르게 하는 기법
    - 즉, 계산한 값을 캐시에 저장하고 이미 캐시된 값을 불러옴으로써 계산 횟수를 줄임
- 동일한 계산을 반복해야 할 경우 한 번 계산한 결과를 메모리에 저장해 두었다가 꺼내 씀으로써 중복 계산을 방지할 수 있게 하는 기법
- 동적 계획법의 핵심이 되는 기술로써 결국 메모리라는 공간 비용을 투입해 계산에 소요되는 시간 비용을 줄임
- 타뷸레이션<sup>Tabulation</sup>: 메모이제이션과 비슷하지만, 값을 미리 계산해둠
    - 즉, 메모이제이션이 결과가 필요할 때 계산한다면(Lazy-Evaluation) 타뷸레이션은 필요하지 않은 값도 미리 계산해둠(Eager-Evaluation)
- 초기화 오버헤드가 있지만 일단 계산해둔 값은 시간복잡도가 상수 시간(O(1))이 됨
- 메모이제이션은 동적 계획법의 핵심
- 계산한 결과를 리스트에 저장함으로써 메모이제이션을 구현할 수 있음
- 동적 계획법을 재귀적으로 수행하다가 동일한 정보가 필요할 때는 미리 구한 계산 결과를 그대로 리스트에서 가져오면 됨

### 탑다운과 보텀업
- 재귀 함수를 이용하여 동적 계획법 소스 코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운<sup>Top-Down</sup> 방식이라고 함
- 반면 단순히 반복문을 사용하여 소스 코드를 작성하는 경우, 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업<sup>Bottom-Up</sup> 방식이라고 함
- 탑다운 방식은 ‘하향식'이라고도 하며, 보텀업 방식은 ‘상향식'이라고도 함
- 메모이제이션은 탑다운 접근 방식을 사용함
- 타뷸레이션은 보텀업 접근 방식을 사용함
- 동적 계획법의 전형적인 형태는 보텀업 방식임
- 하지만 탑다운 방식과 보텀업 방식 모두 동적 계획법을 구현하는 데 사용할 수 있음
- 보텀업 방식에서 사용되는 결과 저장용 리스트를 ‘DP 테이블'이라고 부름
- 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해놓는 넓은 개념을 의미하므로 동적 계획법과는 별도의 개념임
    - 즉, 동적 계획법에 메모이제이션 기법이 사용될 수 있다고 말할 수 있음
    - 메모이제이션이 다이나믹 프로그래밍에 국한된 개념은 아님
- 메모이제이션은 때에 따라 리스트와는 다른 자료형(예를 들어 사전 자료형)을 이용할 수도 있음
- 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 동적 계획법을 적용할 수 있는 지 해결하고자 하는 부분문제들의 중복 여부를 확인
- 단순히 재귀 함수로 비효율적인 프로그램을 작성한 뒤에(탑다운 방식) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면(즉, 메모이제이션을 적용할 수 있으면) 코드를 개선하는 것도 좋은 방법
- 시스템 상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문에 
가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것이 좋음         