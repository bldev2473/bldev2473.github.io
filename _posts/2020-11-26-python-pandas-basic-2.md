---
title: "[Python] Pandas 기본 2"
date: 2020-11-30 23:43:00 -0000
categories: Python
---
앞서 살펴본 시리즈와 데이터프레임은 Pandas에서 데이터를 저장하는 자료구조 객체입니다. 두 객체의 생성 및 초기화, 조작 방법에는 차이가 있으며 Numpy의 배열(ndarray 객체)와도 연관이 있습니다.

자료구조 객체를 초기화하는 것은 데이터를 준비하고 그 데이터를 담을 수 있는 구조에 넣는 것과 같습니다. 시리즈와 데이터프레임의 생성 및 초기화를 위한 데이터의 종류에는 여러가지가 있습니다.

## 1. Series 생성 및 초기화

시리즈를 생성하기 위해서는 Pandas의 Series()를 사용합니다.

Series() 생성자의 기본적인 시그니처(Signature)는 다음과 같습니다.  
> Series(data=None, index=None)

&#45; data: 시리즈에 포함시킬 데이터에 해당됩니다. 리스트, numpy의 ndarray, 딕셔너리, 스칼라 값이 올 수 있습니다.

- Pandas 문서 상에는 배열과 같은(array-like), 반복 가능한(iterable) 자료가 data에 해당된다고 명시되어 있습니다.

&#45; index: 각각의 데이터에 부여할 레이블에 해당됩니다. 리스트가 올 수 있으며 리스트의 원소들이 각각의 데이터에 대한 인덱스에 해당됩니다.

- Pandas는 비유일성(non-unique) 인덱스 값을 지원합니다.

- 인덱스는 유일하지 않아도 되지만 해시값(hash value)을 가지는 해시가능한(hashable) 자료형이어야 합니다. 따라서 해시가능한 자료형인 정수, 문자열, 튜플은 인덱스가 될 수 있지만 해시불가능한 자료형인 리스트, 세트, 딕셔너리는 인덱스가 될 수 없습니다.

- 인덱스는 데이터를 구분하고 데이터를 조회하기 위한 것입니다. 따라서 동일한 인덱스를 이용한 데이터 조회 결과는 항상 일치해야 합니다(동일한 입력에 대해 항상 동일한 출력을 보장). 이러한 이유로 인덱스는 해시가능한 자료형이어야 한다는 조건을 만족해야 합니다.

- 인덱스는 데이터를 구분하는 값입니다(단, 유일성은 없습니다). 따라서 인덱스의 길이는 기본적으로 데이터의 개수와 동일해야 합니다(데이터가 딕셔너리인 경우 일치하지 않아도 되지만 이 경우 데이터에 NaN 값이 들어갑니다).

- 시리즈 생성 시 인덱스가 명시되지 않은 경우 기본적으로 0부터 (데이터의 개수 - 1)까지 차례대로 부여됩니다.

- 인덱스를 사용하여 정수 및 레이블 인덱스 기반 인덱싱 연산(자료구조에서 특정 자료를 가져오는 것)과 데이터 간 연산이 가능합니다.

#### 1) 빈 Series 생성
```python
pd_series = pd.Series()
```
인자를 전달하지 않으면 빈 Series가 생성됩니다.

Series의 타입은 다음과 같으며,  
> <class 'pandas.core.series.Series'>

빈 Series의 출력 결과는 다음과 같습니다.  
> Series([], dtype: float64

기본 자료형은 float64로 설정되어 있음을 알 수 있습니다.

#### 2) Numpy의 배열(ndarray)을 사용한 Series 생성
Numpy의 배열을 데이터로 전달하여 Series를 생성할 수 있습니다.  
```python
np_arr_data = np.array([1, 2, 3, 4, 5])  
pd_series = pd.Series(np_arr_data)
```
인덱스를 인자로 전달하지 않으면 데이터의 개수에 따라 0부터 인덱스가 부여됩니다.

출력 결과는 다음과 같습니다.
> 0    1  
> 1    2  
> 2    3  
> 3    4  
> 4    5  
> dtype: int64  

인덱스는 왼쪽, 데이터는 오른쪽에 세로로 나열된 모습입니다. Pandas의 Series는 이러한 형태로 데이터를 저장하고 저장된 데이터를 출력합니다. 데이터에 따라 인덱스가 부여된 것을 볼 수 있습니다.

인덱스를 인자로 전달하여 Series를 생성할 수도 있습니다. 해쉬가능한 자료형을 원소로 가지는 리스트를 index 옵션에 전달하면 됩니다. 이 때 인덱스의 개수는 Numpy 배열 데이터의 개수(배열의 길이)와 일치해야 합니다. 일치하지 않을 경우 ValueError가 발생합니다.

```python
pd_series = pd.Series(np_arr_data, index=['a', 'b', 'c', 'd', 'e'])
```
> a    1  
> b    2  
> c    3  
> d    4  
> e    5  
> dtype: int64  

위 경우 인덱스는 문자열로 지정되었습니다.

인덱스는 유일하지 않아도 됩니다. 하지만 동일한 인덱스를 사용한 인덱싱 연산 결과는 항상 동일해야 하므로 인덱스의 값은 해시가능한 자료형어야 합니다.

```python
pd_series = pd.Series(np_arr_data, index=['a', 'b', 'a', 'd', 'e'])
pd_series[‘a’]
```
> a    1  
> a    5  
> dtype: int64  

* 해시가능한 자료형이란?  

#### 3) 리스트를 사용한 Series 생성
파이썬의 리스트 자료형을 데이터로 전달하여 Series를 생성할 수 있습니다.

데이터 분석에서 리스트 대신 Numpy 배열을 사용하는 이유는 두 자료형의 여러 차이점에 있지만 형태는 유사합니다. 따라서 Series 생성 방법도 유사합니다. Numpy 배열 대신 리스트를 데이터로 전달하면 되고 인덱스 전달 여부에 따른 출력 결과는 동일합니다.

```python
list_data = [1, 2, 3, 4, 5]
pd_series = pd.Series(list_data)
```
> 0    1  
> 1    2  
> 2    3  
> 3    4  
> 4    5  
> dtype: int64  

```python
pd_series = pd.Series(list_data, index=['a', 'b', 'c', 'd', 'e'])
```
> a    1  
> b    2  
> c    3  
> d    4  
> e    5  
> dtype: int64  

#### 4) 딕셔너리를 사용한 Series 생성
파이썬의 딕셔너리 자료형을 데이터로 전달하여 Series를 생성할 수 있습니다. 다만 Numpy 배열과 리스트를 사용한 경우와는 차이점이 존재합니다.

딕셔너리는 키(Key)와 값(Value)을 가지는 자료형입니다. 딕셔너리를 데이터로 전달하여 Series를 생성할 때 인덱스를 생략하면 기본적으로 딕셔너리의 키가 인덱스가 되고 값이 데이터가 되어 Series가 생성됩니다.

```python
dict_data = {'a':1, 'b':2, 'c':3}
pd_series = pd.Series(dict_data)
```
> a    1  
> b    2  
> c    3  
> dtype: int64

인덱스를 명시적으로 전달할 수도 있습니다. 이 경우 Numpy 배열, 리스트와는 다르게 데이터의 개수만큼 인덱스를 전달하지 않아도 됩니다. 하지만 딕셔너리를 데이터로 전달하는 순간 딕셔너리의 키가 인덱스로 부여되기 때문에 옵션으로 전달한 인덱스에 키 값이 있다면 해당 인덱스에 대한 데이터가 출력되고, 키 값이 없다면 해당 인덱스에 대한 데이터는 NaN으로 출력됩니다.

인덱스를 전달한 출력 결과는 다음과 같습니다.

```python
pd_series = pd.Series(dict_data, index=[0, 1, 2])
```
> 0   NaN  
> 1   NaN  
> 2   NaN  
> dtype: float64  

딕셔너리 데이터의 키 값에는 0, 1, 2가 존재하지 않기 때문에 해당 인덱스에 대한 데이터는 NaN으로 출력되었습니다.

```python
pd_series = pd.Series(dict_data, index=['a', 'b', 'c', 'd'])
```
> a    1.0  
> b    2.0  
> c    3.0  
> d    NaN  
> dtype: float64  

딕셔너리 데이터의 키 값에는 ‘a’, ‘b’, ‘c’가 존재하기 때문에 해당 인덱스에 대한 데이터가 출력되었지만 ‘d’는 존재하지 않기 때문에 인덱스 ‘d’에 대한 데이터는 NaN으로 출력되었습니다.

#### 5) 스칼라 값을 사용한 Series 생성
1차원 배열과 같은 벡터가 아닌 스칼라를 사용하여 Series를 생성할 수도 있습니다.

여기서 스칼라 값은 데이터 자체를 의미하므로 원하는 크기의 Series 생성을 위해서는 추가적으로 데이터의 개수를 명시적으로 정해주어야 합니다. 해당 데이터의 개수를 명시적으로 정하기 위해서는 인덱스를 인자로 전달하면 됩니다. 즉, 인덱스의 개수만큼 스칼라 값에 해당하는 데이터가 생성됩니다. 인덱스를 생략하면 하나의 데이터만 가진 Series가 생성됩니다.

스칼라 값과 인덱스를 사용한 Series 생성 및 출력 결과는 다음과 같습니다.

```python
scalar_data = 'Y'
pd_series = pd.Series(scalar_data, index=[0,1,2,3,4])
```
> 0    Y  
> 1    Y  
> 2    Y  
> 3    Y  
> 4    Y  
> dtype: object  

인덱스의 개수(5개) 만큼 데이터가 생성되었음을 알 수 있습니다.
